// Load common properties
Properties mergedProperties = new Properties();
mergedProperties.load(new FileInputStream("$project.rootDir/../common.properties"));
// Loader-specific gradle.properties takes priority
mergedProperties.load(new FileInputStream("$project.rootDir/gradle.properties"));
mergedProperties.each { prop -> project.ext.set(prop.key, prop.value); }

project.ext.set("mergedProperties", mergedProperties)

// Load secrete tokens
defaultIfNotExist('curseforgeApiToken', System.getenv("CURSEFORGE_TOKEN"))
defaultIfNotExist('modrinthApiToken', System.getenv("MODRINTH_TOKEN"))

def defaultIfNotExist(propertyName, defaultValue) {
	if (!project.hasProperty(propertyName) || project.getProperty(propertyName) == null) {
		project.ext.set(propertyName, defaultValue);
	}
}

/**
 * @param version a version string that looks like "1.21" or "1.20.4"
 * @return a string array that contains exactly 3 strings
 */
def normalizeVersion(versionString) {
	def parts = versionString.split('\\.');
	parts = parts.size() < 3 ? parts + ["0"] * (3 - parts.size()) : parts.take(3);
	return parts.collect { it.toInteger() };
}

/**
 * @param version1 a string array that contains exactly 3 strings
 * @param version2 a string array that contains exactly 3 strings
 * @return 1 if version1>version2, 0 if both are equal, -1 if version1<version2
 */
def compareVersions(version1, version2) {
	for (int i = 0; i < 3; i++) {
		if (version1[i] < version2[i]) return -1;
		if (version1[i] > version2[i]) return 1;
	}
	return 0
}

/**
 * @param version1 a version string that looks like "1.21" or "1.20.4"
 * @param version2 a version string that looks like "1.21" or "1.20.4"
 * @return a string array that contains all versions between [version1, version2], inclusive.
 */
def enumerateVersions(version1, version2) {
	def startMcVersion = normalizeVersion(version1);
	def endMcVersion = normalizeVersion(version2);
	// Make sure startMcVersion <= endMcVersion
	if (compareVersions(startMcVersion, endMcVersion) > 0) {
		def temp = startMcVersion;
		startMcVersion = endMcVersion;
		endMcVersion = temp;
	}
	def currentVersion = startMcVersion.clone();

	def enumeratedVersions = [];
	while (true) {
		if (currentVersion[2] == 0) {
			enumeratedVersions << currentVersion.take(2).join('.');
		} else {
			enumeratedVersions << currentVersion.join('.');
		}

		if (currentVersion == endMcVersion) break;
		currentVersion[2]++;
		if (currentVersion[2] == 10) {
			currentVersion[2] = 0;
			currentVersion[1]++;
			if (currentVersion[1] == 10) {
				currentVersion[1] = 0;
				currentVersion[0]++;
			}
		}
	}

	return enumeratedVersions;
}

project.ext.set('enumeratedMcVersions', project.hasProperty('minecraft_versions_declared') ?
	project.minecraft_versions_declared.split(',').collect { it.trim() } :
	enumerateVersions(project.minecraft_version_min, project.minecraft_version));
println 'The following Minecraft versions will be DECLARED as supported:'
project.enumeratedMcVersions.each { println it };
